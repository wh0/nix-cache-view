<!doctype html>
<div id="root"></div>
<script src="misc.js"></script>
<script>
  (async () => {
    try {
      const options = new URL(window.location).searchParams;
      const cacheBase = options.get('cache_base');
      const hash = options.get('hash');
      const narinfo = await cacheGetNarinfo(cacheBase, hash);
      const nar = await cacheGetNar(cacheBase, narinfo);
      console.log(nar); // %%%

      const renderNode = (name, node) => {
        let vNode, vName;
        switch (node.type) {
          case 'regular':
            vNode = document.createDocumentFragment();
            vName = document.createElement('span');
            vName.textContent = name;
            vNode.appendChild(vName);
            vNode.appendChild(document.createTextNode(' '));
            if (node.executable) {
              const vExecutable = document.createElement('span');
              vExecutable.textContent = 'executable';
              vNode.appendChild(vExecutable);
              vNode.appendChild(document.createTextNode(' '));
            }
            const vPrepare = document.createElement('input');
            vPrepare.type = 'button';
            vPrepare.value = 'create object url';
            vPrepare.onclick = (e) => {
              vPrepare.disabled = true;
              const blob = new Blob([node.contents], {type: 'application/octet-stream'});
              const url = URL.createObjectURL(blob);
              vBlob.href = url;
              vBlob.hidden = false;
            };
            vNode.appendChild(vPrepare);
            vNode.appendChild(document.createTextNode(' '));
            const vBlob = document.createElement('a');
            vBlob.download = name;
            vBlob.hidden = true;
            vBlob.textContent = 'contents';
            vNode.appendChild(vBlob);
            break;
          case 'symlink':
            vNode = document.createDocumentFragment();
            vName = document.createElement('span');
            vName.textContent = name;
            vNode.appendChild(vName);
            vNode.appendChild(document.createTextNode(' '));
            const vSymlink = document.createElement('span');
            vSymlink.textContent = '->';
            vNode.appendChild(vSymlink);
            vNode.appendChild(document.createTextNode(' '));
            const vTarget = document.createElement('span');
            vTarget.textContent = node.target;
            vNode.appendChild(vTarget);
            break;
          case 'directory':
            vNode = document.createElement('details');
            let populated = false;
            vNode.ontoggle = (e) => {
              if (populated) return;
              populated = true;
              vEntries = document.createElement('ul');
              for (const entry of node.entries) {
                const vEntry = document.createElement('li');
                vEntry.appendChild(renderNode(entry.name, entry.node));
                vEntries.appendChild(vEntry);
              }
              vNode.appendChild(vEntries);
            };
            const vSummary = document.createElement('summary');
            vName = document.createElement('span');
            vName.textContent = name;
            vSummary.appendChild(vName);
            vSummary.appendChild(document.createTextNode(` (${node.entries.length})`));
            vNode.appendChild(vSummary);
            break;
          default:
            throw new Error(`unrecognized type ${node.type}`)
        }
        return vNode;
      };
      let rootPath;
      narinfoVisitFields(narinfo, (k, v) => {
        switch (k) {
          case 'StorePath':
            rootPath = v;
            break;
        }
      });
      const rootName = pathName(rootPath);
      document.getElementById('root').appendChild(renderNode(rootName, nar.root));
    } catch (e) {
      console.error(e);
    }
  })();
</script>
