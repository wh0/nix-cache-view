<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>drv view</title>
<style>
  body {
    margin: 1.5rem;
    font-family: sans-serif;
  }
  .drv > dt {
    margin-top: 0.5rem;
  }
  .drv table {
    margin: 0rem -1rem;
    border-spacing: 1rem 0rem;
  }
  .drv thead td {
    border-bottom: 1px solid #d0d0d0;
    vertical-align: bottom;
  }
  .drv td {
    vertical-align: baseline;
  }
  .verbatim {
    font-family: monospace;
    white-space: pre-wrap;
  }
</style>
<dl class="drv">
  <dt>Outputs</dt>
  <dd>
    <table id="outputs">
      <thead>
        <tr>
          <td>Name</td>
          <td>Path</td>
          <td>Hash algorithm</td>
          <td>Hash</td>
        </tr>
      </thead>
    </table>
  </dd>
  <dt>Input derivations</dt>
  <dd>
    <table id="input_drvs">
      <thead>
        <tr>
          <td>Path</td>
          <td>Outputs</td>
        </tr>
      </thead>
    </table>
  </dd>
  <dt>Input sources</dt>
  <dd><ul id="input_srcs"></ul></dd>
  <dt>Platform</dt>
  <dd id="platform"></dd>
  <dt>Builder</dt>
  <dd id="builder"></dd>
  <dt>Builder arguments</dt>
  <dd><ol id="builder_args"></ol></dd>
  <dt>Builder environment</dt>
  <dd>
    <table id="env">
      <thead>
        <tr>
          <td>Name</td>
          <td>Value</td>
        </tr>
      </thead>
    </table>
  </dd>
</dl>
<script src="misc.js"></script>
<script>
  (async () => {
    try {
      const options = new URL(window.location).searchParams;
      const cacheBase = options.get('cache_base');
      const cacheBaseBin = options.get('cache_base_bin') || cacheBase;
      const hash = options.get('hash');

      const drvNarinfo = await cacheGetNarinfo(cacheBase, hash);

      const rootPath = narinfoPath(drvNarinfo);
      const rootName = pathName(rootPath);
      document.title = rootName;

      const drvNar = await cacheGetNar(cacheBase, drvNarinfo);
      const drv = drvParse(new TextDecoder().decode(drvNar.root.contents));

      const [outputs, inputDrvs, inputSrcs, platform, builder, builderArgs, env] = drv;
      const vOutputs = document.getElementById('outputs');
      const vOutputsBody = vOutputs.createTBody();
      for (const [name, path, narHashAlgorithm, narHash] of outputs) {
        const row = vOutputsBody.insertRow(-1);
        row.insertCell(-1).textContent = name;
        const pathCell = row.insertCell(-1);
        const pathLink = document.createElement('a');
        const outputHash = pathHash(path);
        pathLink.href = `nar.html?cache_base=${encodeURIComponent(cacheBaseBin)}&hash=${encodeURIComponent(outputHash)}`;
        pathLink.textContent = path;
        pathCell.appendChild(pathLink);
        row.insertCell(-1).textContent = narHashAlgorithm;
        row.insertCell(-1).textContent = narHash;
      }
      const vInputDrvs = document.getElementById('input_drvs');
      const vInputDrvsBody = vInputDrvs.createTBody();
      for (const [drvPath, drvOutputs] of inputDrvs) {
        const row = vInputDrvsBody.insertRow(-1);
        const drvCell = row.insertCell(-1);
        const drvLink = document.createElement('a');
        const drvHash = pathHash(drvPath);
        drvLink.href = `?cache_base=${encodeURIComponent(cacheBase)}&hash=${encodeURIComponent(drvHash)}`;
        drvLink.textContent = drvPath;
        drvCell.appendChild(drvLink);
        row.insertCell(-1).textContent = drvOutputs.join(', ');
      }
      const inputSrcHashes = {};
      const vInputSrcs = document.getElementById('input_srcs');
      for (const inputSrc of inputSrcs) {
        const item = document.createElement('li');
        const inputSrcLink = document.createElement('a');
        const inputSrcHash = pathHash(inputSrc);
        inputSrcHashes[inputSrcHash] = true;
        inputSrcLink.href = `nar.html?cache_base=${encodeURIComponent(cacheBase)}&hash=${encodeURIComponent(inputSrcHash)}`;
        inputSrcLink.textContent = inputSrc;
        item.appendChild(inputSrcLink);
        vInputSrcs.appendChild(item);
      }
      document.getElementById('platform').textContent = platform;
      const maybeLinkifySingle = (path) => {
        const parts = pathMatch(path);
        if (!parts) return null;
        const link = document.createElement('a');
        const hash = parts[1];
        const isInputSrc = hash in inputSrcHashes;
        const base = isInputSrc ? cacheBase : cacheBaseBin;
        link.href = `nar.html?cache_base=${encodeURIComponent(base)}&hash=${encodeURIComponent(hash)}`;
        link.textContent = path;
        return link;
      };
      const linkifySingle = (path) => {
        return maybeLinkifySingle(path) || document.createTextNode(path)
      };
      const linkify = (text) => {
        // Nix allows '=' too, but that works less well
        // https://github.com/NixOS/nix/blob/2.8.1/src/libstore/path.cc#L14-L17
        return uiNodify(text, /[\/\w+?.-]+/g, (m) => {
          const path = m[0];
          if (!path.startsWith('/')) return null;
          return maybeLinkifySingle(path);
        });
      };
      document.getElementById('builder').appendChild(linkifySingle(builder));
      const vBuilderArgs = document.getElementById('builder_args');
      for (const builderArg of builderArgs) {
        const item = document.createElement('li');
        const vBuilderArg = document.createElement('span');
        vBuilderArg.className = 'verbatim';
        vBuilderArg.appendChild(linkify(builderArg));
        item.appendChild(vBuilderArg);
        vBuilderArgs.appendChild(item);
      }
      const vEnv = document.getElementById('env');
      const vEnvBody = vEnv.createTBody();
      for (const [name, value] of env) {
        const row = vEnvBody.insertRow(-1);
        const vName = document.createElement('span');
        vName.className = 'verbatim';
        vName.textContent = name;
        row.insertCell(-1).appendChild(vName);
        const vValue = document.createElement('span');
        vValue.className = 'verbatim';
        vValue.appendChild(linkify(value))
        row.insertCell(-1).appendChild(vValue);
      }
    } catch (e) {
      console.error(e);
    }
  })();
</script>
